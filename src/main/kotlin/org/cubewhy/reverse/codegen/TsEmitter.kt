package org.cubewhy.reverse.codegen

fun generateNamespaceTs(functions: List<JsProxiedFunction>): String {
    data class Node(
        val children: MutableMap<String, Node> = mutableMapOf(),
        val functions: MutableList<JsProxiedFunction> = mutableListOf()
    )

    val root = Node()

    for (fn in functions) {
        val path = fn.namespace?.split('.') ?: emptyList()
        var current = root
        for (segment in path) {
            current = current.children.getOrPut(segment) { Node() }
        }
        current.functions.add(fn)
    }

    fun JsProxiedFunction.toTsSignature(): String {
        val paramList =
            descriptor.parameterTypes.mapIndexed { i, type -> "arg$i: ${type.toTsType()}" }.joinToString(", ")
        return "$functionName($paramList): ${descriptor.returnType.toTsType()};"
    }

    fun JsProxiedFunction.toTsFunctionImplementation(): String {
        val t = namespace?.replace(".", "_") ?: ""
        val argsList = descriptor.parameterTypes.indices.joinToString(", ") { "arg$it" }
        val paramList =
            descriptor.parameterTypes.mapIndexed { i, type -> "arg$i: ${type.toTsType()}" }.joinToString(", ")

        val callExpr = if (functionName == "invoke") {
            "window[`lunarInternalInvoke_${t}`](window.lunar.token, $argsList)"
        } else {
            "window.lunar.invoke(window.lunar.token, $argsList)"
        }

        return "($paramList) => $callExpr"
    }

    fun renderInterface(node: Node, indent: String = "    "): String {
        val sb = StringBuilder()
        sb.append("{\n")

        // default methods/fields
        if (node.functions[0].namespace == null) {
            // only add this to the unnamed namespace
            sb.append("${indent}token: string;\n")
                .append("${indent}subscribe(name: string, cb: (...args: any[]) => any): void;\n")
                .append("${indent}unsubscribe(name: string, cb: (...args: any[]) => any): void;\n")
                .append("\n")
        }

        for ((name, child) in node.children) {
            sb.append("$indent$name?: ${renderInterface(child, "$indent    ")};\n")
        }

        for (fn in node.functions) {
            sb.append("$indent${fn.toTsSignature()}\n")
        }

        sb.append("${indent.dropLast(4)}}")
        return sb.toString()
    }

    fun renderImplementation(node: Node, path: String = "window.lunar", indent: String = "    "): String {
        val sb = StringBuilder()
        sb.append("$path = {\n")

        for ((name, child) in node.children) {
            if (child.children.isEmpty()) {
                sb.append("$indent$name ")
            } else {
                sb.append("$indent$name: ")
            }
            sb.append(renderImplementation(child, "", "$indent    "))
            sb.append(",\n")
        }

        for (fn in node.functions) {
            sb.append("$indent${fn.functionName}: ${fn.toTsFunctionImplementation()},\n")
        }

        sb.append("${indent.dropLast(4)}}")
        return sb.toString()
    }

    val interfaceCode = "interface LunarNamespace " + renderInterface(root)
    val implCode = renderImplementation(root)

    return """
// generated by https://github.com/earthsworth/LunarJsFunctionAnalyzer
$interfaceCode

declare global {
    interface Window {
        lunar: LunarNamespace;
    }
}

$implCode;

export {};
    """.trimIndent()
}

